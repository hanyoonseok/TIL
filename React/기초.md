# React 
> 리액트는 컴포넌트라는 단위 하나 하나를 합치고 쪼개서 하나의 페이지를 구성하는 형식이다. 

### data flow
- 컴포넌트를 쪼개고 합치기 때문에 자연스럽게 부모 - 자식의 관계가 형성되고, 리액트는 부모에서 자식으로 데이터가 이동하는 단방향 플로우를 사용하기 때문에 자식 -> 부모로의 이동을 불가하다. 

### props
- 자식 컴포넌트가 부모로부터 데이터를 받아올 때 props 값을 통해 받아온다. 즉 쓰이는 곳(부모)에서 값을 정한다 = props
```jsx
//app.js
import React from 'react';
import Hello from './hello';
function App(){
  return(
    <Hello name="han"/>
  )
}

//hello.js
function Hello(props){
  return(
    <div>hi, {props.name}</div>
  )
}
export default Hello;

//실행결과: hi, han
```
- `defaultProps`를 통해 props를 지정하지 않았을 때의 디폴트 값을 명시해줄 수 있음.
```jsx
function Hello(props){
  return(
    <div>hi, {props.name}</div>
  )
}
Hello.defaultProps = {
  name='익명'
}
export default Hello;
```
- 컴포넌트 태그 사이에 넣은 값을 조회하고 싶을 땐, `props.children`을 조회. 즉 쓰임당하는 곳(자식)에서 값을 정한다 = children
```jsx
//app.js
import React from 'react';
import Hello from './Hello';
import Wrapper from './Wrapper';
function App() {
  return (
    <Wrapper>
      <Hello name="react" color="red"/>
      <Hello color="pink"/>
    </Wrapper>
  );
}
export default App;

//wrapper.js
import React from 'react';
function Wrapper({ children }) {
  const style = {
    border: '2px solid red',
  };
  return (
    <div style={style}>
      {children}
    </div>
  )
}
export default Wrapper;

//실행결과: hi, han
//         hi, 익명  //출력되고 빨간 테두리 생김
```

### 조건부 렌더링
- 삼항연산자
```jsx
import React from 'react';

function Hello({ bools }) {
  return (
    <div>
      { bools ? <b>*</b> : null }
      hi
    </div>
  );
}

export default Hello;
```
`bools`가 **true**라면 `*hi` 출력 , **false**라면 `hi`만 출력  

- &&연산자
```jsx
import React from 'react';

function Hello({ bools }) {
  return (
    <div>
      { bools && <b>*</b>}
      hi
    </div>
  );
}

export default Hello;
```
마찬가지로 `bools`가 **true**라면 `*hi` 출력 , **false**라면 `hi`만 출력  

### input 상태관리
- input의 `onChange` 이벤트는 이벤트 객체 `e`를 파라미터로 받아와서 사용 가능.
- `e.target`은 이벤트가 발생한 DOM인 input DOM을 가리킴.
- `e.target.value`를 조회하면 현재 input에 입력한 값을 알 수 있음.

```jsx
//input이 바뀌는 값이 화면에 출력
function InputSample(){
  const [text, setText] = useState('');
  const onChange=(e)=>{
    setText(e.target.value);
  }
  
  return(
    <div>
      <input onChange={onChange} value={text}/>
      <div>값:{text}</div>
    </div>
  )
}
```
- * input의 개수가 여러 개가 되었을 때는 `useState`를 여러 번 사용하고 `onChange`를 여러 개 만들어서 구현할 수도 있지만 좋은 방법이 아님. input에 `name`을 설정하고 이벤트가 발생했을 때 이 값을 참조하도록 하는게 좋음. *
```jsx
function InputSample(){
  const [inputs, setInputs] = useState({
    name:'',
    nickname:''
  });
  const {name, nickname} = inputs; //비구조화 할당을 통해 값 추출
  
  const onChange=(e)=>{
    const {value, name} = e.target; //e.target에서 name과 value 추출
    setInputs({
      ...inputs, //기존의 input 객체 복사
      [name]:value //name 키를 가진 값을 value로 설정
    })
  }
  return(
    <div>
      <input name="name" onChange={onChange} value={name}/>
      <input name="nickname" onChange={onChange} value={nickname}/>
      <div>
        <b>값:</b>
        <b>{name} ({nickname})</b>
      </div>
    </div>
  )
}
export default InputSample;
```
리액트 상태에서 객체 수정해야할 때는 `inputs[name] = value` 이런식으로 수정하면 안됨. 이 방식대로 하면 값을 바꿔도 리렌더링되지 않음. 

### useRef
> javascript의 `getElementById`,`querySelector`처럼 특정 DOM을 선택해야할 때 사용
```jsx
//초기화 버튼을 누르면 마우스 focus가 초기화버튼에 머무르는 것을
//input에 focus가 가도록 하는 예제
import React, {useRef} from "react";
function InputSample(){
  const nameInput = useRef(null);
  const onReset=()=>{
    nameInput.current.focus(); //input의 focus() API 호출
  }
  return(
    <div>
      <input
        name="name"
        placeholder="이름"
        ref={nameInput}
      />
      <button onClick={onReset}>초기화</button>
    </div>
  )
}
export default InputSample;
```
- `useRef()`를 사용하여 Ref객체를 만들고, 내가 선택하고싶은 DOM에 `ref`값을 설정.
- Ref객체의 `.current`값이 내가 원하는 DOM을 가리킴
